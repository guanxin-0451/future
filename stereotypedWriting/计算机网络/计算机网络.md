    
## 计算机网络
  ### 基础
  #### 网络编程
  ##### 套接字（socket）和地址
  - socket：可以看作是对物理世界的直接映射
   ![客户端和服务器工作的核心逻辑](https://cynthia-oss.oss-cn-beijing.aliyuncs.com/1652523845878.png)
    - tcp （字节流套接字 stream socket）。
    - 客户端进程向操作系统内核发起write字节流写操作，内核协议栈将字节流通过网络设备传输到服务器端， 
    - 服务器端从内核得到信息，将字节流从内核读入进程中，并开始业务逻辑的处理。完成后，服务器端反写给客户端。
    - 双向链接
  ####http
  [http2.0](https://www.zhihu.com/question/306768582/answer/595200654)
  - 1.0
  ![](https://cynthia-oss.oss-cn-beijing.aliyuncs.com/1656147131541.png)

  - 1.1是持久化链接
    HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，
    而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应！
    `新增了连接管理即 keepalive ，允许持久连接。
     支持 pipeline，无需等待前面的请求响应，即可发送第二次请求。
     允许响应数据分块（chunked），即响应的时候不标明Content-Length，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件。
     新增缓存的控制和管理。
     加入了 Host 头，用在你一台机子部署了多个主机，然后多个域名解析又是同一个 IP，此时加入了 Host 头就可以判断你到底是要访问哪个主机。`
    ![](https://cynthia-oss.oss-cn-beijing.aliyuncs.com/1656147145278.png)

  - [2.0](https://mp.weixin.qq.com/s/ljtDM1d2KgtxAAhwUFSHkg)
    `
    是二进制协议，不再是纯文本。
    支持一个 TCP 连接发起多请求，移除了 pipeline。
    1个tcp 避免了慢启动，但是会有队头阻塞，而且在移动互联网时代，ip会频繁的换，会导致反复的建立连接。
    利用 HPACK 压缩头部，减少数据传输量。
    允许服务端主动推送数据。
    `
   ![](https://cynthia-oss.oss-cn-beijing.aliyuncs.com/1656147173093.png)

  - 3.0
  ![](https://cynthia-oss.oss-cn-beijing.aliyuncs.com/1656147184776.png)

  - http header
    - Connection 连接方式:keep-alive 持久链接
    - Content-Encoding 压缩方式
  - get&&post
    `get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。
     
     get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。
     
     get 请求在浏览器反复的 回退/前进 操作是无害的，而 post 操作会再次提交表单请求。
     `
  - 解决tcp 拆包粘包
    - 有定义边界CRLF, 解决粘包
    - buffer内读到头发现没读完，把这块进行拷贝赋值到buffer最前端。
    
  - csrf 跨站请求伪造  
    - 恶意链接，执行js 发起对源站点的请求（用源站点的cookie）,浏览器cookie同源策略让恶意站点无法直接拿到。  
    所以通过前端js来执行。
    - csrf防御：http refer 头， 生成token。
    - [go csrf](https://github.com/gorilla/csrf#design-notes)
    - [csrf oauth2] 攻击(https://www.jianshu.com/p/c7c8f51713b6)
  #### osi 七层网络模型
  `
   应用层：应用层是 OSI 标准模型的最顶层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。包括文件传输、电子邮件远程登录和远端接口调用等协议。
   表示层:  表示层向上对应用进程服务，向下接收会话层提供的服务，表示层位于 OSI 标准模型的第六层，表示层的主要作用就是将设备的固有数据格式转换为网络标准传输格式。
   会话层：会话层位于 OSI 标准模型的第五层，它是建立在传输层之上，利用传输层提供的服务建立和维持会话。
   传输层：传输层位于 OSI 标准模型的第四层，它在整个 OSI 标准模型中起到了至关重要的作用。传输层涉及到两个节点之间的数据传输，向上层提供可靠的数据传输服务。传输层的服务一般要经历传输连接建立阶段，数据传输阶段，传输连接释放阶段 3 个阶段才算完成一个完整的服务过程。
   网络层：网络层位于 OSI 标准模型的第三层，它位于传输层和数据链路层的中间，将数据设法从源端经过若干个中间节点传送到另一端，从而向运输层提供最基本的端到端的数据传送服务。
   数据链路层：数据链路层位于物理层和网络层中间，数据链路层定义了在单个链路上如何传输数据。
   物理层：物理层是 OSI 标准模型中最低的一层，物理层是整个 OSI 协议的基础，就如同房屋的地基一样，物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。
   `
  #### tcp
    [tcp]
    https://zhuanlan.zhihu.com/p/141396896  
  ##### tcp/ip协议簇
  - 四层：应用层，传输层，网络层，通讯链路层
  - 应用层
    - DNS 协议  
      DNS 协议是 域名系统协议，英文全称是 Domain Name System，它也是应用层的协议之一，DNS 协议是一个将域名和 IP 相互映射的分布式数据库系统。DNS 缓存能够加快网络资源的访问。
 
    - SMTP 协议  
      SMTP 协议是 简单邮件传输协议，英文全称是 Simple Mail Transfer Protocol，应用层协议之一，SMTP 主要是用作邮件收发协议，SMTP 服务器是遵循 SMTP 协议的发送邮件服务器，用来发送或中转用户发出的电子邮件
    
    - http
    - ssl （会话层）
    `客户端向服务器索要并验证服务器的公钥。 
     双方协商生产「会话秘钥」。
     双方采用「会话秘钥」进行加密通信。
     前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。
     SSL/TLS 的「握手阶段」涉及四次通信
     `
    
  - 传输层
    - udp：datagram socket 数据块套接字  
      UDP 协议就是 用户数据报协议，也就是 User Datagram Protocol，UDP 也是一种传输层的协议，与 TCP 相比，UDP 提供一种不可靠的数据交付，也就是说，UDP 协议不保证数据是否到达目标节点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 是一种无连接的协议，
      传输数据之前源端和终端无需建立连接，不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序等现象。但是 UDP 具有较好的实时性，工作效率较 TCP 协议高。
    - FTP 协议  
      FTP 协议是 文件传输协议，英文全称是 File Transfer Protocol，应用层协议之一，是 TCP/IP 协议的重要组成之一，
      FTP 协议分为服务器和客户端两部分，FTP 服务器用来存储文件，FTP 客户端用来访问 FTP 服务器上的文件，
      FTP 的传输效率比较高，所以一般使用 FTP 来传输大文件。
    
    - tcp
        - 三次握手，   
          第一次握手： 服务端知道了客户端发的能力  发送 标记位为SYN=1 表示建立连接 seq=x 数据包序号为x
          第二次握手： 客户端知道了服务端的收，发能力（收到了上一次握手的的seq并+1发给了客户端） syn， seq = y 序号为y，ack = x+1 
          第三次握手:  服务端知道了客户端的收的能力，收到了才发起了这次请求 ack， seq=x+1， ack = y+1
        - 四次挥手
        [解释](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)
          ```TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。
           
           即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。
           
           TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？
           
           建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。
           释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
           
           所以是“三次握手”，“四次挥手”。
           ```
          ![](https://cynthia-oss.oss-cn-beijing.aliyuncs.com/1652616245239.png)
        - 为什么客户端在TIME-WAIT阶段要等2MSL?  
          ```
          为的是确认服务器端是否收到客户端发出的ACK确认报文
          
          当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。
          
          服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；
          
          如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；
          否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。
          
          所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因
          ```
        - tcp如何保证可靠性？
         `一句话：通过校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制等机制来保证可靠性。
          （1）校验和
          在数据传输过程中，将发送的数据段都当做一个16位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。
          发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。
          （2）序列号
          TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。
          （3）确认应答
          TCP 传输过程中，每次接收方接收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。
          4）超时重传
          在进行 TCP 传输时，由于存在确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟都没有接收到接收方传来的 ACK 报文，那么就对刚刚发送的数据进行重发。
          （5）连接管理 
          就是指三次握手、四次挥手的过程。
          （6）流量控制 
          如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。
          具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。
          （7）拥塞控制
          TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了机制，在开始发送数据的时候，先发少量的数据探探路。
         `
      - tcp如何提高传输效率？
      `TCP 协议如何提高传输效率？
       一句话：TCP 协议提高效率的方式有滑动窗口、快重传、延迟应答、捎带应答等。
       （1）滑动窗口
       如果每一个发送的数据段，都要收到 ACK 应答之后再发送下一个数据段，这样的话我们效率很低，大部分时间都用在了等待 ACK 应答上了。
       为了提高效率我们可以一次发送多条数据，这样就能使等待时间大大减少，从而提高性能。窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。
       （2）快重传
       快重传也叫高速重发控制。
       那么如果出现了丢包，需要进行重传。一般分为两种情况：
       情况一：数据包已经抵达，ACK被丢了。这种情况下，部分ACK丢了并不影响，因为可以通过后续的ACK进行确认；
       情况二：数据包直接丢了。发送端会连续收到多个相同的 ACK 确认，发送端立即将对应丢失的数据重传。
       （3）延迟应答
       如果接收数据的主机立刻返回ACK应答，这时候返回的窗口大小可能比较小。
       假设接收端缓冲区为1M，一次收到了512K的数据；如果立刻应答，返回的窗口就是512K；
       但实际上可能处理端处理速度很快，10ms之内就把512K的数据从缓存区消费掉了；
       在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来；
       如果接收端稍微等一会在应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M；
       窗口越大，网络吞吐量就越大，传输效率就越高；我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。
       （4）捎带应答
       在延迟应答的基础上，很多情况下，客户端服务器在应用层也是一发一收的。这时候常常采用捎带应答的方式来提高效率，而ACK响应常常伴随着数据报文共同传输。如：三次握手。
       `
      - 拆包粘包
        `为什么会发生 TCP 粘包、拆包？
         要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
         待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
         要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
         接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。`
      - 滑动窗口
        `
        窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
        发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。
        接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。
        `
      - 拥塞控制
      `慢开始与拥塞避免
       发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
       注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。
       如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。
       快重传与快恢复
       在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
       在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
       在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。
      `
      - [close wait](https://blog.csdn.net/binglong_world/article/details/80742530)
        - netstat
         `-na | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
          LISTEN 2 
          CLOSE_WAIT 23 # 非常异常 
          TIME_WAIT 1`
        - [查问题](https://zhuanlan.zhihu.com/p/377044076)
          `server端的业务没有正常调起close`
  - 网络层
    - IP 协议  
      IP 是 互联网协议(Internet Protocol) ，位于网络层。IP是整个 TCP/IP 协议族的核心，也是构成互联网的基础。IP 能够为运输层提供数据分发，同时也能够组装数据供运输层使用。它将多个单个网络连接成为一个互联网，这样能够提高网络的可扩展性，实现大规模的网络互联。二是分割顶层网络和底层网络之间的耦合关系。
    - ICMP 协议 ping  
      ICMP 协议是 Internet Control Message Protocol， ICMP 协议主要用于在 IP 主机、路由器之间传递控制消息。ICMP 属于网络层的协议，当遇到 IP 无法访问目标、IP 路由器无法按照当前传输速率转发数据包时，会自动发送 ICMP 消息，从这个角度来说，ICMP 协议可以看作是 错误侦测与回报机制，让我们检查网络状况、也能够确保连线的准确性。
    - ARP 协议  网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）  
      ARP 协议是 地址解析协议，即 Address Resolution Protocol，它能够根据 IP 地址获取物理地址。主机发送信息时会将包含目标 IP 的 ARP 请求广播到局域网络上的所有主机，并接受返回消息，以此来确定物理地址。收到消息后的物理地址和 IP 地址会在 ARP 中缓存一段时间，下次查询的时候直接从 ARP 中查询即可。
    - NDP IPv6
    
  - 数据链路层
    - SLIP 协议  
      SLIP 协议是指串行线路网际协议（Serial Line Internet Protocol)，是在串行通信线路上支持 TCP/IP 协议的一种点对点(Point-to-Point)式的链路层通信协议。
    
    - PPP 协议  
      PPP 协议是 Point to Point Protocol，即点对点协议，是一种链路层协议，是在为同等单元之间传输数据包而设计的。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。
    
    
  #### 常见问题
  ##### 拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？[链接](https://mp.weixin.qq.com/s/0YFsUWL6e9r_aDrCZeTK3w)
  - tcp保活 keep alive
  `
   而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：
   
   如果对端是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。
   如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
   `
  ##### tcp自连接：
  - 原因 当一方主动发起连接时，操作系统会自动分配一个临时端口号给连接主动发起方。如果刚好分配的临时端口恰好是目标服务的端口，目标服务又不在线。
  会导致自连接
  - 解决：golang tcp connect
  ` selfConnect 方法的判断，判断是否是自连接的逻辑是判断源 IP 和目标 IP 是否相等，源端 口号和目标端口号是否相等。`
  ##### [二十道题](https://mp.weixin.qq.com/s/3FTuMZaUrT9Vw-ZScJkQbg)
  ##### 单点登陆
  `
  如果是不同域的情况下，Cookie是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 Web服务
  
  用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 token 写入 Cookie（注意这个 Cookie是认证中心的，应用系统是访问不到的）
  
  应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心
  
  由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了
  
  如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录
  
  如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL，并在跳转前生成一个 Token，拼接在目标URL 的后面，回传给目标应用系统
  
  应用系统拿到 Token之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token写入Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了
  
  此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法
  `
  ##### session cookie的区别
  `
  session伪造： 登陆成功后返回新的seesionid，防止旧的会话id还能用。
  
  `
  ##### token 验证登录
  `基于token机制的身份认证流程：
   
   客户端使用用户名和密码请求登录。
   服务端收到请求，验证用户名和密码。
   验证成功后，服务端会生成一个token，然后把这个token发送给客户端。
   客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。
   客户端每次向服务端发送请求的时候都需要带上服务端发给的token。
   服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。`
  ##### [https](https://mp.weixin.qq.com/s/21JaXwdfSjItj5SgOwhapg)
  `HTTPS 的出发点是解决HTTP明文传输时信息被篡改和监听的问题。
   
   为了兼顾性能和安全性，使用了非对称加密+对称加密的方案。
   对称加密： AES 位运算  非对称加密: RSA 幂运算
   为了保证公钥传输中不被篡改，又使用了非对称加密的数字签名功能，借助CA机构和系统根证书的机制保证了HTTPS证书的公信力。`
  ##### [键入网址后，期间发生了什么？](https://mp.weixin.qq.com/s/I6BLwbIpfGEJnxjDcPXc1A)
  - http协议解析Url
  - dns 域名解析
  - 传输层： tcp, udp
    `三次握手，生成报文， 批量发送`
  - 网络层
    `IP协议封装成网络包`
  - 加 MAC 头部 封装成mac包
  - ARP协议找到路由器的mac地址， ARP在以太网广播
  - 网卡出口转为电信号
  - 交换机 （无mac地址）
  - 路由器（有mac地址）
  - 服务器接收
  `MAC 地址符合，符合就将包收起来。
   
   接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。
   
   于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。
   
   于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。
   
   服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。
   
   HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。
   
   穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。
   
   最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。
   
   客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！
   
   于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！
   
   最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。
   如果迟迟收不到这个 ACK，内核就会重发 FIN 报文，如果重传的次数超过 tcp_orphan_retries 内核参数设置的次数，就会放弃重传，然后进入close状态。
`
  ##### [http常见30个问题](https://mp.weixin.qq.com/s/amOya0M00LwpL5kCS96Y6w)
  
  ### Gossip协议
  - 周期性扩散消息，感染周围节点
  - Gossip 的特点（优势）
    1. 扩展性  
    网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。
    2. 容错  
    网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。
    3. 去中心化  
    Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。 
    4. 一致性收敛  
    Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。
    5. 简单  
    Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。
  - 缺陷
    1）消息的延迟  
    由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。
    2）消息冗余  
    Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。
    
    
    
