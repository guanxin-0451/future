## 逃逸分析
### 逃逸分析是什么
  - 概念：当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸（到堆上）。
    - 堆：适合不可预知大小的内存分配，分配速度较慢，会形成内存碎片。分配时首先要找到1块大小合适的内存块，之后需要垃圾回收释放。
    - 栈：只需要通过push指令，并且会被自动释放。
      - go语言在运行时，防止碎片化，会在合适的时候对整个栈进行深拷贝，将其整个复制到另一块内存区域。
      - **指针的算术运算不能奏效，go可能会移动他。**
    - go 的堆栈 都是go运行时申请的堆内存。
    - 用户态go程序的栈空间，有1gb。
  - golang做了什么: 一个变量在堆上还是栈上分配，由编译器的逃逸分析之后得到结论。
  - 在编译原理中: 分析指针动态范围的方法被称为逃逸分析。
### 逃逸分析有什么用
  - 不需要开发人员关心内存分配和回收，内存的复杂管理交给编译器。
  - 把变量合理的分配道堆/栈上。
    - 用new分配的，如果这块内存在退出函数后就没有用了，那就分配到栈上，栈上分配快。
    - 普通变量，但是被多个方法引用，那就分配到堆上。
    - 如果都分配到堆上，堆不像栈可以自动清理，会频繁引发go的垃圾回收。开销大。
  - 作用：通过逃逸分析，尽量把不需要分配到堆上的内存分配到栈上
    - 减轻内存分配的开销。
    - 降低gc的压力。
    - 提高程序运行速度。
### 逃逸分析是怎么完成的
  - 基本原则：  
    - 如果一个函数返回对一个变量的引用，那么这个变量就会发生逃逸。
    - 只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上。
  - 策略：
    - 如果变量在函数外部没有引用，**优先**放在栈上。
      - 如果需要申请的内存过大，超过了栈的存储能力，则放在堆上。
    - 如果变量在函数外部存在引用，**必定**放在堆上。
    - interface类型的传参，编译期间不能确定具体类型，也会发生逃逸。
  - 分配到堆上的情况分类：
    - 局部指针返回
    - 栈空间不足
    - 动态类型
    - 闭包引用

### 如何确定是否发生逃逸
  - `go build -gcflags '-m -l' main.go`
    - 启用编译器支持的额外标志，-m 输出优化细节

### 如何避免逃逸
  - 尽量减少外部指针引用，必要的时候可以使用值传递。
  - 对于自己定义的数据大小，有一个基本的预判，尽量不要出现栈空间溢出的情况。
  - Golang中的接口类型的方法调用是动态调度，如果对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型。
  - 对于大对象等，尽量不用闭包函数。

### 面试如何讲：
  - 什么是逃逸分析  
    - 分析指针动态范围的方法被称为逃逸分析
    - 确定一个变量在堆上还是栈上分配
  - 逃逸分析的作用  
    通过逃逸分析，尽量把不需要分配到堆上的内存分配到栈上
    - 减轻内存分配的开销。
    - 降低gc的压力。
    - 提高程序运行速度。
  - go的堆栈和操作系统的堆栈区别  
    堆栈都是用户态的堆分配出来的
    - 用户态go程序的栈空间，有1gb。
    - 适合不可预知大小的内存分配，分配速度较慢，会形成内存碎片。分配时首先要找到1块大小合适的内存块，之后需要垃圾回收释放。
  - go的逃逸分析策略（如何确定分配到堆还是栈）
    - 如果变量在函数外部没有引用，**优先**放在栈上。
      - 如果需要申请的内存过大，超过了栈的存储能力，则放在堆上。
    - 如果变量在函数外部存在引用，**必定**放在堆上。
    - interface类型的传参，编译期间不能确定具体类型，也会发生逃逸。
  - 分配到堆上的情况分类：
    - 局部指针返回
    - 栈空间不足
    - 动态类型
    - 闭包引用
  - 如何检查是否有逃逸
    - `go build -gcflags '-m -l' main.go`
  - 如何避免逃逸
    - 尽量减少外部指针引用，必要的时候可以使用值传递。
    - 对于自己定义的数据大小，有一个基本的预判，尽量不要出现栈空间溢出的情况。
    - Golang中的接口类型的方法调用是动态调度，如果对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型。
    - 对于大对象等，尽量不用闭包函数。